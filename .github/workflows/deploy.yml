name: Deploy to TestFlight & Google Play

on:
  # D√©ploiement automatique sur push vers master
  push:
    branches:
      - master
      - main

  # D√©ploiement manuel depuis l'interface GitHub
  workflow_dispatch:
    inputs:
      platform:
        description: 'Platform to deploy'
        required: true
        type: choice
        options:
          - both
          - android
          - ios
        default: 'both'

jobs:
  # ==========================================
  # JOB ANDROID - Build et Deploy sur Google Play
  # ==========================================
  deploy-android:
    name: ü§ñ Android ‚Üí Google Play
    env:
      EXPO_PUBLIC_API_BASE_URL: ${{ secrets.EXPO_PUBLIC_API_BASE_URL }}
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.platform == 'android' || github.event.inputs.platform == 'both'))
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Install dependencies (excluding dev dependencies for Release)
        run: npm ci --omit=dev

      - name: üíæ Backup Fastlane configuration
        run: |
          mkdir -p /tmp/fastlane-backup
          cp -r android/fastlane /tmp/fastlane-backup/ || echo "No fastlane folder to backup"

      - name: üìù Create .env file for API URL
        run: |
          if [ -z "${{ secrets.EXPO_PUBLIC_API_BASE_URL }}" ]; then
            echo "‚ö†Ô∏è WARNING: EXPO_PUBLIC_API_BASE_URL secret is not set!"
            echo "The app will use the default API URL from the code."
          else
            echo "EXPO_PUBLIC_API_BASE_URL=${{ secrets.EXPO_PUBLIC_API_BASE_URL }}" > .env
            echo "‚úÖ .env file created with API URL"
            # Verify the file was created (without showing the actual URL)
            if [ -f ".env" ]; then
              echo "‚úÖ .env file exists"
              echo "API URL configured: EXPO_PUBLIC_API_BASE_URL=***"
            else
              echo "‚ùå ERROR: .env file was not created"
              exit 1
            fi
          fi

      - name: üî® Generate Android native folder
        run: |
          # Export the variable so it's available during prebuild
          export EXPO_PUBLIC_API_BASE_URL="${{ secrets.EXPO_PUBLIC_API_BASE_URL }}"
          npx expo prebuild --platform android --clean

      - name: üìã Restore Fastlane configuration
        run: |
          cp -r /tmp/fastlane-backup/fastlane android/
          echo "Fastlane configuration restored"
          ls -la android/fastlane/

      - name: üîß Fix build.gradle - Remove problematic blocks
        run: |
          echo "üîß Fixing build.gradle syntax issues..."
          BUILD_GRADLE="android/app/build.gradle"
          if [ -f "$BUILD_GRADLE" ]; then
            # Show first few lines for debugging
            echo "üìÑ First 20 lines of build.gradle:"
            head -n 20 "$BUILD_GRADLE" || true
            
            python3 <<EOF
          file_path = 'android/app/build.gradle'
          with open(file_path, 'r', encoding='utf-8') as f:
              lines = f.readlines()
          
          # Show lines around potential problematic areas
          print('üîç Searching for problematic blocks...')
          
          # First, find all occurrences of buildTypes
          buildtypes_occurrences = []
          for i, line in enumerate(lines, 1):
              stripped = line.strip()
              if 'buildTypes' in stripped and '{' in line:
                  buildtypes_occurrences.append(i)
                  print(f'üìç Found buildTypes at line {i}')
          
          if len(buildtypes_occurrences) > 1:
              print(f'‚ö†Ô∏è WARNING: Found {len(buildtypes_occurrences)} buildTypes blocks! Keeping only the first one.')
          
          for i, line in enumerate(lines, 1):
              if 'androidResources' in line or 'packagingOptions' in line or 'packaging {' in line:
                  print(f'üìç Found potential issue at line {i}:')
                  start = max(0, i - 3)
                  end = min(len(lines), i + 10)
                  for j in range(start, end):
                      marker = '>>> ' if j == i - 1 else '    '
                      print(f'{marker}{j+1:3d}: {lines[j].rstrip()}')
          
          # Count braces to verify structure
          content = ''.join(lines)
          open_braces = content.count('{')
          close_braces = content.count('}')
          print(f'üìä Braces before: {open_braces} open, {close_braces} close')
          
          output = []
          skip_block = False
          brace_count = 0
          removed_blocks = []
          block_start_line = 0
          buildtypes_count = 0
          
          for i, line in enumerate(lines, 1):
              # Detect start of problematic blocks (more flexible matching)
              stripped = line.strip()
              
              # Detect duplicate buildTypes blocks (keep only the first one)
              if 'buildTypes' in stripped and '{' in line:
                  buildtypes_count += 1
                  if buildtypes_count > 1:
                      print(f'üö´ Found duplicate buildTypes at line {i}, removing it')
                      skip_block = True
                      removed_blocks.append(f'duplicate buildTypes (line {i})')
                      brace_count = line.count('{') - line.count('}')
                      block_start_line = i
                      continue
                  else:
                      print(f'‚úÖ Keeping first buildTypes block at line {i}')
              
              if 'androidResources' in stripped and '{' in line:
                  print(f'üö´ Found androidResources at line {i}: {stripped}')
                  skip_block = True
                  removed_blocks.append(f'androidResources (line {i})')
                  brace_count = line.count('{') - line.count('}')
                  block_start_line = i
                  continue
              
              if ('packagingOptions' in stripped or 'packaging {' in stripped) and '{' in line:
                  print(f'üö´ Found packaging/packagingOptions at line {i}: {stripped}')
                  skip_block = True
                  removed_blocks.append(f'packaging (line {i})')
                  brace_count = line.count('{') - line.count('}')
                  block_start_line = i
                  continue
              
              # If we're inside a problematic block, count braces
              if skip_block:
                  brace_count += line.count('{') - line.count('}')
                  if brace_count <= 0:
                      print(f'‚úÖ Finished removing block at line {i} (started at line {block_start_line})')
                      skip_block = False
                      block_start_line = 0
                  continue
              
              # Keep all other lines
              output.append(line)
          
          # Verify structure after removal
          output_content = ''.join(output)
          open_braces_after = output_content.count('{')
          close_braces_after = output_content.count('}')
          print(f'üìä Braces after: {open_braces_after} open, {close_braces_after} close')
          
          if open_braces_after != close_braces_after:
              print(f'‚ö†Ô∏è WARNING: Brace mismatch! This may cause syntax errors.')
              print(f'   Difference: {open_braces_after - close_braces_after} braces')
          
          # Verify only one buildTypes block remains
          buildtypes_count_after = output_content.count('buildTypes {')
          if buildtypes_count_after > 1:
              print(f'‚ùå ERROR: Still {buildtypes_count_after} buildTypes blocks after cleanup!')
          elif buildtypes_count_after == 1:
              print(f'‚úÖ Verified: Only 1 buildTypes block remains')
          else:
              print(f'‚ö†Ô∏è WARNING: No buildTypes block found after cleanup!')
          
          # Show lines around line 133 (where the error occurs)
          print('üîç Showing lines around 130-140 (error location):')
          for i, line in enumerate(output, 1):
              if 130 <= i <= 140:
                  print(f'    {i:3d}: {line.rstrip()}')
          
          with open(file_path, 'w', encoding='utf-8') as f:
              f.write(output_content)
          
          print(f'‚úÖ build.gradle fixed (removed: {", ".join(removed_blocks) if removed_blocks else "none"})')
          EOF
            echo "‚úÖ build.gradle syntax fixed"
            
            # Show lines around 133 for debugging
            echo "üîç Showing lines around 130-140:"
            sed -n '130,140p' "$BUILD_GRADLE" || true
            
            # Verify the file is still valid
            echo "üîç Verifying build.gradle structure..."
            if grep -q "android {" "$BUILD_GRADLE" && grep -q "^}" "$BUILD_GRADLE"; then
              echo "‚úÖ build.gradle structure looks valid"
            else
              echo "‚ö†Ô∏è WARNING: build.gradle structure may be invalid"
            fi
            
            # Try to validate Gradle syntax by checking if we can parse it
            echo "üîç Validating Gradle syntax..."
            cd android
            if ./gradlew tasks --dry-run > /dev/null 2>&1; then
              echo "‚úÖ Gradle syntax validation passed"
            else
              echo "‚ö†Ô∏è WARNING: Gradle syntax validation failed, but continuing..."
              echo "Showing Gradle error output:"
              ./gradlew tasks --dry-run 2>&1 | head -50 || true
            fi
            cd ..
          else
            echo "‚ö†Ô∏è WARNING: build.gradle not found"
          fi

      - name: üîß Configure release signing in build.gradle
        run: |
          echo "üîß Configuring release signing in build.gradle..."
          BUILD_GRADLE="android/app/build.gradle"
          
          if [ ! -f "$BUILD_GRADLE" ]; then
            echo "‚ùå ERROR: build.gradle not found. expo prebuild may have failed."
            exit 1
          fi
          
          # Create backup
          cp "$BUILD_GRADLE" "$BUILD_GRADLE.backup"
          
          # Check if signingConfigs.release already exists
          if grep -q "signingConfigs.release" "$BUILD_GRADLE" || (grep -A 10 "signingConfigs {" "$BUILD_GRADLE" | grep -q "release {"); then
            echo "‚úÖ signingConfigs.release already exists"
          else
            # Add release config after debug config in signingConfigs block
            awk '
              /signingConfigs \{/ { 
                print
                in_signing = 1
                next
              }
              in_signing && /^    \}/ {
                print "        release {"
                print "            if (project.hasProperty(\"MAYA_UPLOAD_STORE_FILE\")) {"
                print "                storeFile file(MAYA_UPLOAD_STORE_FILE)"
                print "                storePassword MAYA_UPLOAD_STORE_PASSWORD"
                print "                keyAlias MAYA_UPLOAD_KEY_ALIAS"
                print "                keyPassword MAYA_UPLOAD_KEY_PASSWORD"
                print "            }"
                print "        }"
                print
                in_signing = 0
              }
              { print }
            ' "$BUILD_GRADLE" > "$BUILD_GRADLE.tmp" && mv "$BUILD_GRADLE.tmp" "$BUILD_GRADLE"
            echo "‚úÖ Added signingConfigs.release"
          fi
          
          # Ensure release buildType uses signingConfigs.release instead of debug
          if grep -A 10 "release {" "$BUILD_GRADLE" | grep -q "signingConfig signingConfigs\.debug"; then
            echo "‚ö†Ô∏è  WARNING: Release buildType is using debug signing! Fixing..."
            sed -i '/release {/,/^    }/s/signingConfig signingConfigs\.debug/signingConfig signingConfigs.release/g' "$BUILD_GRADLE"
            echo "‚úÖ Fixed: Replaced debug signing with release signing"
          elif grep -A 10 "release {" "$BUILD_GRADLE" | grep -q "signingConfig signingConfigs.release"; then
            echo "‚úÖ Release buildType already uses signingConfigs.release"
          else
            echo "‚ö†Ô∏è  No signingConfig found in release block, adding signingConfigs.release"
            sed -i '/release {/a\            signingConfig signingConfigs.release' "$BUILD_GRADLE"
            echo "‚úÖ Added signingConfig signingConfigs.release to release buildType"
          fi
          
          # Final verification - ensure release does NOT use debug
          if grep -A 10 "release {" "$BUILD_GRADLE" | grep -q "signingConfig signingConfigs\.debug"; then
            echo "‚ùå ERROR: Release buildType still uses debug signing after configuration!"
            echo "Build.gradle content around release block:"
            grep -A 10 "release {" "$BUILD_GRADLE"
            exit 1
          else
            echo "‚úÖ Verification passed: Release buildType uses release signing (not debug)"
          fi
          
          echo "‚úÖ Release signing configuration complete"

      - name: üîß Set gradlew permissions
        working-directory: android
        run: |
          chmod +x gradlew
          echo "‚úÖ Gradlew permissions set"

      - name: üîß Generate React Native Codegen artifacts
        working-directory: android
        run: |
          echo "Generating codegen artifacts for all modules..."
          # Generate codegen artifacts for all native modules, not just the app
          ./gradlew generateCodegenArtifactsFromSchema --stacktrace || {
            echo "‚ö†Ô∏è Codegen generation had issues, but continuing..."
            exit 0
          }
          echo "‚úÖ Codegen artifacts generated"

      - name: üíé Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: üîê Decode Android keystore
        run: |
          echo "üì¶ Decoding keystore from GitHub secret..."
          mkdir -p android/app
          # Decode base64 keystore and save to android/app/
          # Support both old secret name (ANDROID_KEYSTORE_BASE64) and new (MAYA_UPLOAD_KEYSTORE_BASE64)
          if [ -n "${{ secrets.MAYA_UPLOAD_KEYSTORE_BASE64 }}" ]; then
            echo "${{ secrets.MAYA_UPLOAD_KEYSTORE_BASE64 }}" | base64 --decode > android/app/maya-upload.keystore
            KEYSTORE_SECRET="MAYA_UPLOAD_KEYSTORE_BASE64"
          elif [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ]; then
            echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 --decode > android/app/maya-upload.keystore
            KEYSTORE_SECRET="ANDROID_KEYSTORE_BASE64"
          else
            echo "‚ùå ERROR: No keystore secret found!"
            echo "Please set either MAYA_UPLOAD_KEYSTORE_BASE64 or ANDROID_KEYSTORE_BASE64 in GitHub Secrets"
            exit 1
          fi
          
          if [ ! -f "android/app/maya-upload.keystore" ]; then
            echo "‚ùå ERROR: Failed to create keystore file"
            exit 1
          fi
          
          echo "‚úÖ Keystore decoded successfully at android/app/maya-upload.keystore"
          ls -lh android/app/maya-upload.keystore
          
          # Optional: Verify keystore SHA1 if expected value is provided
          if [ -n "${{ secrets.MAYA_UPLOAD_EXPECTED_SHA1 }}" ] || [ -n "${{ secrets.ANDROID_KEYSTORE_EXPECTED_SHA1 }}" ]; then
            echo "üîç Verifying keystore SHA1..."
            KEY_ALIAS="${{ secrets.MAYA_UPLOAD_KEY_ALIAS || secrets.ANDROID_KEY_ALIAS }}"
            STORE_PASSWORD="${{ secrets.MAYA_UPLOAD_STORE_PASSWORD || secrets.ANDROID_KEYSTORE_PASSWORD }}"
            EXPECTED_SHA1="${{ secrets.MAYA_UPLOAD_EXPECTED_SHA1 || secrets.ANDROID_KEYSTORE_EXPECTED_SHA1 }}"
            
            if [ -z "$KEY_ALIAS" ] || [ -z "$STORE_PASSWORD" ]; then
              echo "‚ö†Ô∏è WARNING: Cannot verify SHA1 - missing alias or password"
            else
              SHA1=$(keytool -list -v -keystore android/app/maya-upload.keystore -alias "$KEY_ALIAS" -storepass "$STORE_PASSWORD" 2>/dev/null | grep "SHA1:" | awk '{print $2}' || echo "")
              echo "Keystore SHA1: $SHA1"
              if [ "$SHA1" = "$EXPECTED_SHA1" ]; then
                echo "‚úÖ Keystore SHA1 matches expected value!"
              else
                echo "‚ùå ERROR: Keystore SHA1 does NOT match expected value!"
                echo "Expected: $EXPECTED_SHA1"
                echo "Got:      $SHA1"
                echo ""
                echo "This will cause Google Play to reject the AAB."
                echo "Please update the keystore secret with the correct keystore."
                exit 1
              fi
            fi
          else
            echo "‚ÑπÔ∏è Skipping SHA1 verification (no expected SHA1 secret provided)"
          fi

      - name: ‚öôÔ∏è Configure signing properties (Gradle)
        run: |
          echo "‚öôÔ∏è Configuring signing properties in gradle.properties..."
          # Ensure gradle.properties exists (expo prebuild may or may not create it)
          if [ ! -f "android/gradle.properties" ]; then
            echo "Creating android/gradle.properties..."
            touch android/gradle.properties
          fi
          
          # Remove any existing MAYA_UPLOAD properties to avoid duplicates
          if [ -f "android/gradle.properties" ]; then
            sed -i.bak '/^MAYA_UPLOAD/d' android/gradle.properties || sed -i '/^MAYA_UPLOAD/d' android/gradle.properties
          fi
          
          # Append signing properties to gradle.properties
          # Support both old and new secret names for backward compatibility
          cat >> android/gradle.properties <<EOF
          # Android signing configuration (injected at CI runtime)
          MAYA_UPLOAD_STORE_FILE=maya-upload.keystore
          MAYA_UPLOAD_STORE_PASSWORD=${{ secrets.MAYA_UPLOAD_STORE_PASSWORD || secrets.ANDROID_KEYSTORE_PASSWORD }}
          MAYA_UPLOAD_KEY_ALIAS=${{ secrets.MAYA_UPLOAD_KEY_ALIAS || secrets.ANDROID_KEY_ALIAS }}
          MAYA_UPLOAD_KEY_PASSWORD=${{ secrets.MAYA_UPLOAD_KEY_PASSWORD || secrets.ANDROID_KEY_PASSWORD }}
          EOF
          echo "‚úÖ Signing properties configured"
          # Show the properties (without passwords) for verification
          echo "Configured properties:"
          grep "MAYA_UPLOAD" android/gradle.properties | sed 's/PASSWORD=.*/PASSWORD=***/' || true
          
          # Also add other Gradle settings if they don't exist
          if ! grep -q "org.gradle.jvmargs" android/gradle.properties; then
            cat >> android/gradle.properties <<EOF
          
          # Gradle settings
          org.gradle.jvmargs=-Xmx2048m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
          org.gradle.parallel=true
          org.gradle.configureondemand=true
          android.useAndroidX=true
          android.enableJetifier=true
          
          # React Native / Hermes settings
          hermesEnabled=true
          newArchEnabled=true
          EOF
            echo "‚úÖ Additional Gradle settings added"
          fi

      - name: üîë Create Google Play service account JSON
        run: |
          mkdir -p android/fastlane
          echo '${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}' > android/fastlane/google-play-service-account.json
          echo "Service account configured"

      - name: üöÄ Deploy to Google Play Internal Testing
        working-directory: android
        run: bundle exec fastlane internal
        env:
          SUPPLY_JSON_KEY: ./fastlane/google-play-service-account.json

      - name: üîç Verify AAB signature (prevent debug signature)
        run: |
          echo "üîç Verifying AAB signature to ensure it's NOT signed with debug keystore..."
          AAB_PATH="android/app/build/outputs/bundle/release/app-release.aab"
          
          if [ ! -f "$AAB_PATH" ]; then
            echo "‚ùå ERROR: AAB file not found at $AAB_PATH"
            exit 1
          fi
          
          echo "‚úÖ AAB file found, extracting and verifying signature..."
          
          # Extract the AAB and check the signature
          # The AAB is a zip file, we need to extract it and check the signing
          TEMP_DIR=$(mktemp -d)
          unzip -q "$AAB_PATH" -d "$TEMP_DIR" || {
            echo "‚ùå ERROR: Failed to extract AAB"
            rm -rf "$TEMP_DIR"
            exit 1
          }
          
          # Check if there's a META-INF folder with signature files
          if [ ! -d "$TEMP_DIR/META-INF" ]; then
            echo "‚ùå ERROR: AAB is not signed! Missing META-INF folder"
            rm -rf "$TEMP_DIR"
            exit 1
          fi
          
          # Get the SHA1 of the certificate from the AAB
          # We can use jarsigner or apksigner to verify
          if command -v apksigner >/dev/null 2>&1; then
            echo "Using apksigner to verify signature..."
            # Convert AAB to APK for verification (or use bundletool)
            CERT_SHA1=$(apksigner verify --print-certs "$AAB_PATH" 2>/dev/null | grep "SHA-1" | head -1 | awk '{print $2}' || echo "")
          elif command -v jarsigner >/dev/null 2>&1; then
            echo "Using jarsigner to verify signature..."
            CERT_SHA1=$(jarsigner -verify -verbose -certs "$AAB_PATH" 2>&1 | grep "SHA1" | head -1 | awk '{print $3}' | tr -d '()' || echo "")
          else
            echo "‚ö†Ô∏è WARNING: Neither apksigner nor jarsigner found, skipping signature verification"
            CERT_SHA1=""
          fi
          
          rm -rf "$TEMP_DIR"
          
          if [ -n "$CERT_SHA1" ]; then
            echo "AAB Certificate SHA1: $CERT_SHA1"
            EXPECTED_SHA1="1C:3B:87:09:A5:5B:A3:74:A3:C2:7A:98:AF:23:06:82:C7:B1:AF:FD"
            
            # Normalize SHA1 format (remove colons for comparison)
            CERT_SHA1_NORMALIZED=$(echo "$CERT_SHA1" | tr -d ':')
            EXPECTED_SHA1_NORMALIZED=$(echo "$EXPECTED_SHA1" | tr -d ':')
            
            if [ "$CERT_SHA1_NORMALIZED" = "$EXPECTED_SHA1_NORMALIZED" ]; then
              echo "‚úÖ AAB is correctly signed with the release keystore!"
            else
              # Check if it's the debug keystore (common debug SHA1)
              DEBUG_SHA1_PATTERNS="61:ED:37:7E:85:D3:86:A8:DF:EE:6B:86:4B:D8:5B:0B:FA:A5:AF:81"
              if echo "$CERT_SHA1" | grep -q "61:ED:37:7E:85:D3"; then
                echo "‚ùå ERROR: AAB is signed with DEBUG keystore!"
                echo "This will be rejected by Google Play."
                echo "Expected release SHA1: $EXPECTED_SHA1"
                echo "Got debug SHA1: $CERT_SHA1"
                exit 1
              else
                echo "‚ö†Ô∏è WARNING: AAB SHA1 does not match expected release keystore"
                echo "Expected: $EXPECTED_SHA1"
                echo "Got:      $CERT_SHA1"
                echo "Continuing, but this may cause issues with Google Play..."
              fi
            fi
          else
            echo "‚ö†Ô∏è WARNING: Could not extract SHA1 from AAB signature"
            echo "Continuing, but signature verification was skipped"
          fi

      - name: üì§ Upload Android artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: android-release-aab
          path: android/app/build/outputs/bundle/release/app-release.aab
          retention-days: 30

      - name: ‚úÖ Android deployment success
        if: success()
        run: |
          echo "‚úÖ Android app successfully deployed to Google Play Internal Testing!"
          echo "üì± Go to Google Play Console to test: https://play.google.com/console/"

  # ==========================================
  # JOB iOS - Build et Deploy sur TestFlight
  # ==========================================
  deploy-ios:
    name: üçé iOS ‚Üí TestFlight
    env:
      _EXPO_PUBLIC_API_BASE_URL: ${{ vars._EXPO_PUBLIC_API_BASE_URL }}
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.platform == 'ios' || github.event.inputs.platform == 'both'))
    runs-on: macos-15  # macOS 15 has Xcode 16.x

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Install dependencies (excluding dev dependencies for Release)
        run: npm ci --omit=dev

      - name: üîß Select Xcode 16.1
        run: |
          sudo xcode-select -s /Applications/Xcode_16.1.app/Contents/Developer
          xcodebuild -version

      - name: üî® Generate iOS native folder
        run: npx expo prebuild --platform ios --clean

      - name: üîß Fix iOS nullability issues
        run: |
          chmod +x scripts/fix-ios-nullability.sh
          bash scripts/fix-ios-nullability.sh

      - name: üîß Set iOS deployment target in Xcode project
        run: |
          # Find the Xcode project file dynamically
          PROJECT_FILE=$(find ios -name "project.pbxproj" -type f | head -n 1)
          if [ -n "$PROJECT_FILE" ]; then
            echo "üì± Found Xcode project at: $PROJECT_FILE"
            sed -i '' 's/IPHONEOS_DEPLOYMENT_TARGET = [^;]*/IPHONEOS_DEPLOYMENT_TARGET = 13.4/g' "$PROJECT_FILE"
            echo "‚úÖ Set IPHONEOS_DEPLOYMENT_TARGET to 13.4"
            # Verify the change
            echo "üîç Verification:"
            grep "IPHONEOS_DEPLOYMENT_TARGET" "$PROJECT_FILE" | head -n 3
          else
            echo "‚ö†Ô∏è Warning: Could not find Xcode project.pbxproj file"
            exit 1
          fi

      - name: üíé Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: üßπ Clean Xcode Derived Data
        run: rm -rf ~/Library/Developer/Xcode/DerivedData

      - name: üîß Configure Podfile build settings
        working-directory: ios
        run: |
          echo "üîß Adding custom build settings to Podfile post_install hook"

          # Insert custom build settings into the existing post_install hook
          sed -i '' '/post_install do |installer|/a\
          \  # Custom build settings\
          \  installer.pods_project.targets.each do |target|\
          \    target.build_configurations.each do |config|\
          \      config.build_settings["IPHONEOS_DEPLOYMENT_TARGET"] = "13.4"\
          \      config.build_settings["GCC_WARN_INHIBIT_ALL_WARNINGS"] = "YES"\
          \      config.build_settings["SWIFT_SUPPRESS_WARNINGS"] = "YES"\
          \    end\
          \  end\
          ' Podfile

          echo "‚úÖ Podfile configured"

      - name: üì¶ Install CocoaPods dependencies
        working-directory: ios
        run: |
          pod install
          echo "‚úÖ CocoaPods dependencies installed"

      - name: üîß Set deployment target for all Pods
        run: |
          cd ios
          echo "Setting IPHONEOS_DEPLOYMENT_TARGET for all Pods to 13.4"
          find Pods -name "project.pbxproj" -type f | while read -r file; do
            sed -i '' 's/IPHONEOS_DEPLOYMENT_TARGET = [^;]*/IPHONEOS_DEPLOYMENT_TARGET = 13.4/g' "$file"
          done
          echo "‚úÖ All Pods deployment targets updated"

      - name: üîß Disable Swift 6 strict concurrency checking
        run: |
          PROJECT_FILE=$(find ios -name "project.pbxproj" -type f | head -n 1)
          if [ -n "$PROJECT_FILE" ]; then
            echo "üì± Disabling strict concurrency checking in: $PROJECT_FILE"
            awk '/buildSettings = \{/ {print; print "\t\t\t\tSWIFT_STRICT_CONCURRENCY = minimal;"; next}1' "$PROJECT_FILE" > "$PROJECT_FILE.tmp"
            mv "$PROJECT_FILE.tmp" "$PROJECT_FILE"
            echo "‚úÖ Swift strict concurrency checking disabled"
          fi

      - name: üîê Setup App Store Connect API Key
        run: |
          mkdir -p ios/fastlane/keys
          echo "${{ secrets.APP_STORE_CONNECT_KEY_BASE64 }}" | base64 -d > ios/fastlane/keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
          chmod 600 ios/fastlane/keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
          echo "App Store Connect API Key configured"

      - name: üìú Setup Match certificates
        working-directory: ios
        run: bundle exec fastlane match appstore --readonly
        env:
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: ${{ secrets.FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD }}

      - name: üöÄ Build and Deploy to TestFlight
        working-directory: ios
        run: bundle exec fastlane beta
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}

      - name: üì§ Upload iOS artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ios-release-ipa
          path: ios/*.ipa
          retention-days: 30

      - name: ‚úÖ iOS deployment success
        if: success()
        run: |
          echo "‚úÖ iOS app successfully deployed to TestFlight!"
          echo "üì± Go to App Store Connect to test: https://appstoreconnect.apple.com/"

  # ==========================================
  # JOB NOTIFICATION - R√©sum√© final
  # ==========================================
  notify-success:
    name: üì¢ Deployment Summary
    needs: [deploy-android, deploy-ios]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: üìä Deployment Summary
        run: |
          echo "======================================"
          echo "üéâ DEPLOYMENT COMPLETED"
          echo "======================================"
          echo ""
          echo "Android Status: ${{ needs.deploy-android.result }}"
          echo "iOS Status: ${{ needs.deploy-ios.result }}"
          echo ""
          if [ "${{ needs.deploy-android.result }}" == "success" ]; then
            echo "‚úÖ Android: https://play.google.com/console/"
          fi
          if [ "${{ needs.deploy-ios.result }}" == "success" ]; then
            echo "‚úÖ iOS: https://appstoreconnect.apple.com/"
          fi
          echo ""
          echo "======================================"
